stages:
  - build
  - deploy

variables:
  WERF_IMAGES_REPO_MODE: monorepo
  GIT_SUBMODULE_STRATEGY: recursive
  GIT_SUBMODULE_DEPTH: 1
  KUBE_NAMESPACE: sockshop
  DOCKER_REGISTRY: index.docker.io

.init_werf_script: &init_werf_script
  - source $(werf ci-env gitlab --as-file)
  - werf cr login -u ${CI_DOCKER_HUB_USER} -p ${CI_DOCKER_HUB_PASSWORD} ${DOCKER_REGISTRY}
  - werf cr  login -u ${CI_DEPENDENCY_PROXY_USER} -p ${CI_DEPENDENCY_PROXY_PASSWORD} ${CI_DEPENDENCY_PROXY_SERVER}
  - echo {CI_DEPENDENCY_PROXY_SERVER}
  - echo ${CI_DEPENDENCY_PROXY_USER}
  - echo ${CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX}

.base_job:
  image:
    name: registry.werf.io/werf/werf:1.2
  before_script:
    - *init_werf_script

Build and Publish:
  extends: .base_job
  stage: build
  script:
    - werf build

Deploy:
  extends: .base_job
  stage: deploy
  script:
    - werf kubectl config use-context gitlab-instance-711bf56d/sockshop:k8s-4otus-agent
    - werf kubectl config current-context
    - |
      werf kubectl create namespace ${KUBE_NAMESPACE} || true
      werf kubectl -n ${KUBE_NAMESPACE} create secret docker-registry gitlab-credentials --docker-server="${CI_REGISTRY}" --docker-username="${CI_REGISTRY_USER}" --docker-password="${CI_REGISTRY_PASSWORD}" --docker-email="${GITLAB_USER_EMAIL}" -o yaml --dry-run=client | werf kubectl apply -f -
      werf kubectl -n ${KUBE_NAMESPACE} patch serviceaccount default -p '{"imagePullSecrets": [ { "name": "gitlab-credentials" } ] }'
    - werf converge --skip-build --set "env_url=$(echo ${CI_ENVIRONMENT_URL} | cut -d / -f 3)"


